<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>DSC Tokenization - World Foundation Models</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "DSC Tokenization";
        var mkdocs_page_input_path = "tokens/dsc_tokenization.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> World Foundation Models
        </a>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../projeto/escopo/">Projeto</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Referências</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../../diffusion/diffusion/">Diffusion models</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../autoregressive/autoregressive/">Autoregressive models</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" >Tokens</a>
    <ul class="current">
                <li class="toctree-l2"><a class="reference internal" >Cosmos Tokenizer</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../cosmos_tokenizer/cosmos_tokenizer/">Cosmos Tokenizer</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../cosmos_tokenizer/wavelet_compression/">Image Decomposition With Wavelets | Decomposição de imagem com Wavelets</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2 current"><a class="reference internal current" href="#">DSC Tokenization</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#portugues">Português</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#visao-geral">Visão geral</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#o-que-e-tokenizacao">O que é Tokenização?</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#metodos-simples-de-tokenizacao">Métodos simples de tokenização</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#tokenizacao-no-processo-de-geracao-de-texto-de-llms">Tokenização no processo de geração de texto de LLMs</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#4-maneiras-de-economizar-tokens-de-entrada-e-saida">4 maneiras de economizar tokens de entrada e saída</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#implementacao-de-tokenizacao-word-level">Implementação de tokenização word-level</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#english">English</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#what-is-tokenization">What is Tokenization?</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#simple-tokenization-methods">Simple tokenization methods</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#tokenization-in-the-llm-text-generation-process">Tokenization in the LLM text generation process</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#4-ways-to-save-input-and-output-tokens">4 Ways to Save Input and Output Tokens</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#implementation-of-word-level-tokenizing">Implementation of word level tokenizing</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#referencias-references">Referências | References</a>
    </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../cosmos_applications/cosmos_applications/">Cosmos Applications</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">World Foundation Models</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Referências</li>
          <li class="breadcrumb-item">Tokens</li>
      <li class="breadcrumb-item active">DSC Tokenization</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="data-science-collective-tokenization">Data Science Collective - Tokenization</h1>
<p><strong><em>Authors / Autores: <a href="http://github.com/yuri-sl">@yuri-sl</a></em>, <a href="http://github.com/figredos">@figredos</a></strong></p>
<h2 id="portugues">Português</h2>
<h3 id="visao-geral">Visão geral</h3>
<p>A IA generativa transformou profundamente nosso cotidiano nos últimos anos, possibilitando desde resumos e traduções automatizadas até geração de código e até suporte a aprendizado personalizado. A “moeda” essencial por trás dessa tecnologia avançada é o token. A maioria dos modelos cobra com base no número de tokens de entrada fornecidos e nos tokens de saída que geram.</p>
<p>Mas o que é um token, pelo processamento do qual pagamos tanto? Entender o que são tokens, como são gerados a partir de texto e quais são suas principais características são os primeiros passos para construir aplicações mais eficientes e aproveitar ao máximo a IA generativa.</p>
<h3 id="o-que-e-tokenizacao">O que é Tokenização?</h3>
<p>Tokenização é a etapa de pré-processamento de texto em tarefas de PLN que divide o texto de entrada em subpalavras, palavras ou caracteres individuais. Um token é a menor unidade de medida processada por um modelo de IA generativa. Durante o treinamento, esses tokens são fornecidos ao modelo para processamento. O tamanho de um token (uma unidade de entrada) varia entre os modelos. Não há uma estratégia unificada de tokenização; elas são escolhidas pelos desenvolvedores de acordo com a tarefa em questão.</p>
<p>É possível ter uma noção de várias estratégias de tokenização experimentando este projeto de tokenização do Hugging Face, que visualiza essas estratégias para modelos populares.</p>
<p><img alt="Tokenizer Playground" src="../images/dsc_images/tokenizer_playground.webp" /></p>
<p><em>O Tokenizer Playground visualiza como um grande modelo de linguagem divide o texto em tokens individuais. Aqui, a frase “The quick brown fox jumps over the lazy dog.” é dividida em 10 tokens, demonstrando a primeira etapa no pipeline de processamento de texto de um LLM.</em></p>
<blockquote>
<p>Isso significa que cada modelo só pode ser usado para inferência em combinação com o tokenizador no qual foi treinado.</p>
</blockquote>
<p>Após o treinamento, tokens únicos são armazenados em um conjunto especial chamado vocabulário para Grandes Modelos de Linguagem, e no Cookbook para modelos de geração de imagem e áudio.</p>
<h3 id="metodos-simples-de-tokenizacao">Métodos simples de tokenização</h3>
<p>As abordagens mais simples de tokenização são a tokenização em nível de palavra e a tokenização em nível de caractere.</p>
<ul>
<li><strong>Tokenização em nível de palavra</strong> : divide o texto de entrada por espaços em branco e caracteres especiais, como vírgulas, pontos de interrogação ou pontos de exclamação. Depois de dividir o texto em palavras, cria-se um vocabulário a partir dos tokens únicos, onde cada token é mapeado para um inteiro. O vocabulário pode ser usado para transformar cada sentença em uma representação vetorial numérica.</li>
<li><img alt="Word Level Tokenization" src="../images/dsc_images/word_level_tokenization.webp" /></li>
</ul>
<p>No entanto, assim que se deseja codificar texto que não é do corpus de entrada e contém palavras não incluídas no vocabulário, nem todas as palavras podem ser tokenizadas. Essas palavras são chamadas de fora do vocabulário e são representadas por um token especial, como <code>&lt;|unk|&gt;</code>. Portanto, “Fora do vocabulário” é a forma educada da IA de dizer: “Não faço ideia do que você acabou de dizer, mas aqui vai uma resposta genérica.”</p>
<p><img alt="Handling Unknown Words" src="images/dsc_images/hadling_unk_words.webp" /></p>
<p>Uma forma de lidar com esse problema é a tokenização em nível de caractere.</p>
<ul>
<li><strong>Tokenização em nível de caractere</strong>: processa o texto no nível de caracteres, resultando em um tamanho de vocabulário muito menor. Assim, em vez de um token por palavra, uma palavra é representada por uma combinação de muitos tokens.</li>
</ul>
<p>Infelizmente, essa estratégia também tem suas falhas. Como a tokenização é realizada no nível de caractere, os tokens perdem o significado contextual, o que torna mais difícil para o modelo aprender gramática. Além disso, essa estratégia de tokenização resulta em sequências mais longas.</p>
<p><img alt="Character Level Tokenization" src="../images/dsc_images/character_level_tokenization.webp" /></p>
<p><em>Tokenização em nível de caractere: Cada caractere em “The quick brown fox” recebe um ID de token único, resultando em sequências de tokens mais longas, mas eliminando problemas de fora do vocabulário.</em></p>
<p>Isso evidencia que ambas as estratégias de tokenização têm seus problemas. Por essa razão, modelos como o ChatGPT usam um método que encontra um equilíbrio entre ambas — Byte Pair Encoding (BPE), que será abordado no próximo post desta série.</p>
<h3 id="tokenizacao-no-processo-de-geracao-de-texto-de-llms">Tokenização no processo de geração de texto de LLMs</h3>
<p>A relevância da tokenização fica clara quando se vê onde ela se situa no processo de geração de texto dos LLMs.</p>
<p>Ao enviar uma consulta de entrada a um LLM, o texto é dividido em tokens e ingerido pelo modelo. Esses tokens são as unidades essenciais pelas quais se paga, e são subsequentemente transformados em números para que a máquina possa “entendê-los”.</p>
<p>Após a geração de uma resposta pelo LLM, ele retorna uma lista de tokens numéricos, que então são destokenizados para que humanos possam entender a saída — porque, infelizmente, não somos tão rápidos quanto os computadores no processamento de números.</p>
<p>Por esses tokens de entrada e saída, os provedores de LLM nos cobram. Portanto, faz sentido manter ambos os lados o mais curtos possível, o que diminui o tempo de processamento e economiza dinheiro.</p>
<p><img alt="Text Gen Pipeline" src="../images/dsc_images/text_gen_pipeline.webp" /></p>
<h3 id="4-maneiras-de-economizar-tokens-de-entrada-e-saida">4 maneiras de economizar tokens de entrada e saída</h3>
<p>Economizar tokens é o equivalente, na IA, a apagar as luzes ao sair do cômodo.</p>
<p><img alt="Tokens Power AI" src="../images/dsc_images/tokens_power_ai.webp" /></p>
<p>Então, para economizar energia, apague sua luz e não deixe seu fluxo de trabalho de IA rodar em um loop infinito processando tokens sem fim, por mais baratos que sejam. Aqui estão três dicas de como atingir esse objetivo.</p>
<p>1.Remove Unnecessary Context
Remova instruções repetitivas, saudações, despedidas ou detalhes irrelevantes. Inclua apenas o que o modelo precisa saber para gerar uma resposta de alta qualidade</p>
<p>2.Optimize Prompt Engineering
Use instruções concisas e claras. Evite explicações verbosas ou exemplos desnecessários. Prompts bem elaborados podem reduzir o tamanho da entrada e guiar o modelo com mais eficiência.</p>
<p>3.Set Maximum Output Lengths
A maioria das APIs de LLM permite definir um limite máximo de tokens para saídas (por exemplo, <em>max_tokens</em>). Ajuste essa configuração para garantir que a resposta do modelo não seja mais longa do que o necessário.
4.Chunk Large Tasks
Se houver um documento ou tarefa grande, divida-o em partes menores e processe-as sequencialmente. Isso reduz o uso de tokens por requisição e permite reutilizar contexto, economizando tokens de entrada e de saída.</p>
<h3 id="implementacao-de-tokenizacao-word-level">Implementação de tokenização word-level</h3>
<p>Nos blocos de código Python a seguir, implementaremos a tokenização word-level , detalhando cada etapa para uma compreensão mais profunda. Os dois textos usados neste exemplo são contos de fadas gerados pelo ChatGPT usando o prompt: “Generate a fairy tale about AI”, e os resultados, no meu caso, foram “Arti the Useful Intelligence” e “Pixel the Dream.” Ambos os textos serão tokenizados por palavras nas linhas de código subsequentes.</p>
<p><img alt="AI Fairy Tales" src="../images/dsc_images/ai_fairy_tales.webp" /></p>
<p><em>Contos de fadas de IA na tokenização: “Pixel the Dreamer” e “Artie the Helpful Intelligence” são dois textos de exemplo usados para demonstrar a tokenização word-level neste tutorial.</em></p>
<p>É possível encontrar todo o notebook Jupyter no repositório <a href="https://github.com/FLX-20/AI-Explained">GitHub de Python</a> para esta série de posts.</p>
<h4 id="carregando-os-arquivos-de-texto">Carregando os arquivos de texto</h4>
<p>Primeiro, carregamos o texto do arquivo de texto no nosso ambiente Python.</p>
<pre><code class="language-python">import re

def open_txt_file(file_path):
    with open(file_path, 'r') as file:
        content = file.read()
    return content
</code></pre>
<p>O texto carregado pode ser verificado imprimindo os primeiros 100 caracteres de ambas as histórias.</p>
<pre><code class="language-python">text_1 = open_txt_file('pixel-the-dreamer.txt')
print(text_1[:100] + &quot;...&quot;)
</code></pre>
<pre><code class="language-python">text_2 = open_txt_file('artie-the-helpful-intelligence.txt')
print(text_2[:100] + &quot;...&quot;)
</code></pre>
<h4 id="gerar-vocabulario-e-vocabulario-reverso">Gerar vocabulário e vocabulário reverso</h4>
<p>Agora, construímos nosso vocabulário incluindo todas as palavras únicas do texto de entrada. O vocabulário define como cada palavra é mapeada para um valor inteiro, e isso é feito primeiro dividindo o texto por espaços em branco e caracteres especiais usando expressões regulares. Dependendo da expressão regular escolhida, espaços em branco podem ser considerados um tipo de token ou podem ser completamente ignorados.</p>
<p>A escolha de remover espaços em branco depende da aplicação. Embora a remoção desse tipo de caractere diminua a demanda por recursos computacionais, manter espaços em branco é benéfico para o processamento de linguagens de programação; em algumas linguagens de programação, esses espaços são essenciais devido à sensibilidade à indentação e ao espaçamento e não podem ser ignorados.</p>
<p>No exemplo acima, os espaços em branco são ignorados porque estamos lidando com texto bruto, que não é sensível à indentação.</p>
<p>É possível incluir espaços em branco usando esta expressão regular:</p>
<pre><code class="language-python">r'([\w+|\s+|^\w\s])'
</code></pre>
<p>Em seguida, espaços em branco remanescentes são removidos dos tokens para que apenas a palavra ou o caractere especial permaneça. Além disso, é gerado um vocabulário reverso, necessário para converter os tokens de volta em texto.</p>
<pre><code class="language-python">def generate_vocab(text):
    chunks = re.split(r'(\w+|[^\w\s])', text)
    unique_tokens = [c for c in chunks if c.strip()]
    encode_vocab = {token: idx for idx, token in enumerate(unique_tokens)}
    decode_vocab = {idx: token for idx, token in enumerate(unique_tokens)}

    return encode_vocab, decode_vocab
</code></pre>
<pre><code class="language-python">encode_vocab, decode_vocab = generate_vocab(text_1)
</code></pre>
<p>Vamos dar uma olhada na criação do nosso vocabulário.</p>
<pre><code class="language-python">print(&quot;Vocabulary (token -&gt; index):&quot;)
for idx, token in enumerate(encode_vocab):
    print(f&quot;{idx} -&gt; '{token}'&quot;)
</code></pre>
<p>No total, nosso vocabulário consiste de 204 palavras únicas.</p>
<pre><code class="language-python">print(&quot;Number of unique tokens:&quot;, len(encode_vocab))
</code></pre>
<h4 id="tokenizando-um-texto">Tokenizando um texto</h4>
<p>Agora estamos prontos para tokenizar textos de entrada com base no vocabulário criado. O processo de tokenização começa de forma semelhante ao processo de criação do vocabulário, em que o texto é dividido em palavras e caracteres especiais, usando a mesma expressão regular de antes.</p>
<p>Em seguida, o vocabulário é usado para substituir cada palavra no texto por seu número correspondente no vocabulário ou pelo token &lt;|unk|&gt; se a palavra não existir no vocabulário.</p>
<p>Ao final, é retornada a representação final do texto tokenizado.</p>
<pre><code class="language-python">def encode_text(text, encode_vocab):
    tokens = re.split(r'(\w+|[^\w\s])', text)
    tokens = [t for t in tokens if t.strip()]
    tokens = [encode_vocab.get(token, &quot;&lt;|unk|&gt;&quot;) for token in tokens]
    return tokens
</code></pre>
<p>Vamos testar a função de tokenização anterior no texto inicial, que também foi usado para criar o vocabulário.</p>
<pre><code class="language-python">encoded_text = encode_text(text_1, encode_vocab)
print(&quot;Encoded text:&quot;, encoded_text)
</code></pre>
<p>Agora, vamos também testar a função no segundo texto, que não foi usado para a geração do vocabulário.</p>
<pre><code class="language-python">encoded_text = encode_text(text_2, encode_vocab)
print(&quot;Encoded text:&quot;, encoded_text)
</code></pre>
<p>É possível ver que aconteceu exatamente como previsto anteriormente. Nem todas as palavras do segundo texto estão presentes no primeiro texto, que foi usado para gerar o vocabulário, resultando em muitos tokens desconhecidos fora do vocabulário.</p>
<p>Neste momento, há duas possibilidades para resolver esse problema: Pode-se usar tokenização em nível de caractere ou adicionar as palavras fora do vocabulário ao nosso vocabulário. No próximo bloco de código, seguiremos adicionando as palavras desconhecidas ao vocabulário.</p>
<p>Isso é feito adicionando ambos os textos, separados pelo token <code>&lt;|endoftext|&gt;</code>, que indica ao modelo que o próximo texto não está relacionado ao anterior. Em seguida, as mesmas funções são reutilizadas para gerar a representação em tokens do texto de entrada.</p>
<pre><code class="language-python">text_corpus = text_1 + &quot; &lt;|endoftext|&gt; &quot; + text_2
encode_vocab, decode_vocab = generate_vocab(text_corpus)
encoded_text = encode_text(text_2, encode_vocab)
print(&quot;Encoded text:&quot;, encoded_text)
</code></pre>
<h4 id="destokenizacao">Destokenização</h4>
<p>Ao final, queremos voltar ao texto original a partir da representação em tokens, para que possamos entendê-lo e interpretá-lo, o que é exatamente a etapa que ocorre após um Grande Modelo de Linguagem gerar sua saída. As representações numéricas produzidas pelo LLM são convertidas de volta pelo destokenizador em informação textual.</p>
<p>Aqui, é necessário o vocabulário reverso, que mapeia tokens de volta para palavras. O processo de destokenização é semelhante ao de tokenização: pegam-se os números da lista de tokens e eles são substituídos pelas palavras correspondentes do vocabulário, separadas por espaço em branco. Esses espaços são removidos antes de caracteres especiais porque eles estão sempre anexados a uma palavra.</p>
<p>A lista final é retornada e impressa.</p>
<pre><code class="language-python">def decode_text(tokens, decode_vocab):
    text = ' '.join(decode_vocab.get(idx,'&lt;|unk|&gt;') for idx in tokens)
    text = re.sub(r'\s([?.!,&quot;](?:\s|$))', r'\1', text)
    return text
</code></pre>
<pre><code class="language-python">decode_text = decode_text(encoded_text, decode_vocab)
print(decode_text)
</code></pre>
<h4 id="conclusao">Conclusão</h4>
<p>Nesta exploração da tokenização, revelamos os blocos de construção fundamentais que alimentam os sistemas modernos de IA generativa. O post destacou que existem diferentes estratégias de tokenização, que variam entre os modelos.</p>
<p>As duas estratégias mais simples — tokenização word-level e tokenização em nível de caractere — foram introduzidas e implementadas, com seus prós e contras discutidos. O problema de fora do vocabulário encontrado na tokenização por palavras, assim como o grande comprimento da lista de tokens na codificação em nível de caractere, evidenciaram que é necessária uma solução intermediária.</p>
<p>Essa solução é o Byte Pair Encoding (BPE), usado por quase todos os modelos modernos.</p>
<h2 id="english">English</h2>
<h3 id="overview">Overview</h3>
<p>Generative AI has profoundly transformed our daily lives in recent years, enabling everything from automated summaries and translations to code generation and even personalized learning support. The essential “currency” behind this advanced technology is the token. Most models charge based on the number of input tokens you provide and the output tokens they generate.</p>
<p>But what is a token, for the processing of which we pay so much? Understanding what are tokens, how are they generated from text, and what are their key characteristics, are the first steps toward building more efficient applications, and -making the most of generative AI.</p>
<h3 id="what-is-tokenization">What is Tokenization?</h3>
<p>Tokenization is the text preprocessing step in NLP tasks that splits the input text into individual sub-words, words, or characters. A token is the smallest unit of measurement processed by a generative AI model. During its training, these tokens are provided to the model for processing. The size of a token (one input unit) varies between models. There is no unified tokenization strategy, they are chosen by developers according to the task at hand.</p>
<p>You can get an impression of various tokenization strategies by experimenting with this Hugging Face tokenization project, which visualizes these strategies for popular models.</p>
<p><img alt="Tokenizer Playground" src="../images/dsc_images/tokenizer_playground.webp" /></p>
<p><em>The <strong>Tokenizer Playground</strong> visualizes how a large language model splits text into individual tokens. Here, the sentence “The quick brown fox jumps over the lazy dog.” is divided into 10 tokens, demonstrating the first step in the LLM text processing pipeline.</em></p>
<blockquote>
<p>This means that each model can only be used for inference in combination with the tokenizer it was trained on.</p>
</blockquote>
<p>After training, unique tokens are stored in a special set called the vocabulary for Large Language Models, and the Cookbook for image and audio generation models.</p>
<h3 id="simple-tokenization-methods">Simple tokenization methods</h3>
<p>The simplest tokenization approaches are word-level tokenization and character-level tokenization.</p>
<ul>
<li><strong>Word-level tokenization</strong>: splits the input text by whitespaces and special characters, such as commas, question marks, or exclamation points. After splitting the text into words, a vocabulary is created from the unique tokens, where each token is mapped to an integer. The vocabulary can be used to transform each sentence into a numerical vector representation.</li>
<li><img alt="Word Level Tokenization" src="../images/dsc_images/word_level_tokenization.webp" /></li>
</ul>
<p>However, as soon as we want to encode text that is not from the input corpus and contains words not included in the vocabulary, not all words can be tokenized. These words are referred to as out-of-vocabulary tokens and are represented by a special token, such as <code>&lt;|unk|&gt;</code>. So “Out-of-vocabulary” is AI’s polite way of saying, “No idea what you just said, but here’s a generic response.”</p>
<p><img alt="Handling Unknown Words" src="images/dsc_images/hadling_unk_words.webp" /></p>
<p>One way to address this problem is character-level tokenization.</p>
<ul>
<li><strong>Character-level tokenization</strong>: processes text at the character level, resulting in a much smaller vocabulary size. Thus, instead of one token per word, a word is represented by a combination of many tokens.</li>
</ul>
<p>Unfortunately, this strategy also has its flaws. Because tokenization is performed at the character level, the tokens lose contextual meaning, which makes it more difficult for the model to learn grammar. Moreover, this tokenization strategy results in longer sequences.</p>
<p><img alt="Character Level Tokenization" src="../images/dsc_images/character_level_tokenization.webp" /></p>
<p><em>Character-level tokenization: Every character in “The quick brown fox” is assigned a unique token ID, resulting in longer token sequences but eliminating out-of-vocabulary issues.</em></p>
<p>This highlights that both tokenization strategies have their problems. For this reason, models such as ChatGPT use a method that strikes a balance between both — Byte Pair Encoding (BPE), which will be covered in the next post of this series.</p>
<h3 id="tokenization-in-the-llm-text-generation-process">Tokenization in the LLM text generation process</h3>
<p>The relevance of tokenization becomes clear when you see where it is situated in the text generation process of LLMs.</p>
<p>When you pass an input query to an LLM, your text is split into tokens and ingested into the model. These tokens are the essential units you are paying for, and they are subsequently turned into numbers so that the machine can “understand” them.</p>
<p>After an answer has been generated by the LLM, it returns a list of numerical tokens, which are then detokenized so that we humans can understand the output — because unfortunately, we are not as fast as computers at processing numbers.</p>
<p>For these input and output tokens, the LLM providers make us pay. So it makes sense to keep both ends as short as possible, which decreases processing time and saves money.</p>
<p><img alt="Text Gen Pipeline" src="../images/dsc_images/text_gen_pipeline.webp" /></p>
<h3 id="4-ways-to-save-input-and-output-tokens">4 Ways to Save Input and Output Tokens</h3>
<p>Saving tokens is the AI equivalent of turning off the lights when you leave the room.</p>
<p><img alt="Tokens Power AI" src="../images/dsc_images/tokens_power_ai.webp" /></p>
<p>So, to save energy, switch off your light and don’t let your AI workflow run in an infinite loop processing endless tokens, no matter how cheap they are. Here are three tips on how this goal can be achieved.</p>
<p><strong>1.Remove Unnecessary Context</strong>
Strip out repetitive instructions, greetings, sign-offs, or irrelevant details. Only include what the model needs to know to generate a high-quality response</p>
<p><strong>2.Optimize Prompt Engineering</strong>
Use concise and clear instructions. Avoid verbose explanations or unnecessary examples. Carefully designed prompts can reduce input size and guide the model more efficiently.</p>
<p><strong>3.Set Maximum Output Lengths</strong>
Most LLM APIs allow you to set a maximum token limit for outputs (e.g., <em>max_tokens</em>). Adjust this setting to ensure the model’s response isn’t longer than needed.
<strong>4.Chunk Large Tasks</strong>
If you have a large document or task, break it into smaller parts and process them sequentially. This reduces per-request token usage and allows you to reuse context, saving both input and output tokens.</p>
<h3 id="implementation-of-word-level-tokenizing">Implementation of word level tokenizing</h3>
<p>In the following Python code blocks, we will implement word-level tokenization, breaking down every step for a deeper understanding. The two texts used for this example are fairy tales generated by ChatGPT using the prompt: “Generate a fairy tale about AI”, and the results in my case were “Arti the Useful Intelligence” and “Pixel the Dream.” Both texts will be tokenized by words in the subsequent lines of code.</p>
<p><img alt="AI Fairy Tales" src="../images/dsc_images/ai_fairy_tales.webp" /></p>
<p><em>AI fairy tales in tokenization: “Pixel the Dreamer” and “Artie the Helpful Intelligence” are two example texts used for demonstrating word-level tokenization in this tutorial.</em></p>
<p>You can find the entire Jupyter notebook in the Python <a href="https://github.com/FLX-20/AI-Explained">GitHub repo</a> for this post series.</p>
<h4 id="loading-the-text-files">Loading the text files</h4>
<p>First, we load the text from the text file in our Python environment.</p>
<pre><code class="language-python">import re

def open_txt_file(file_path):
    with open(file_path, 'r') as file:
        content = file.read()
    return content
</code></pre>
<p>The loaded text can be checked by printing out the first 100 characters of both stories.</p>
<pre><code class="language-python">text_1 = open_txt_file('pixel-the-dreamer.txt')
print(text_1[:100] + &quot;...&quot;)
</code></pre>
<pre><code class="language-python">text_2 = open_txt_file('artie-the-helpful-intelligence.txt')
print(text_2[:100] + &quot;...&quot;)
</code></pre>
<h4 id="generate-vocabulary-and-reverse-vocabulary">Generate vocabulary and reverse vocabulary</h4>
<p>Now, we build our vocabulary including all unique words of the input text. The vocabulary defines how each word is mapped to an integer value, and is achieved by first splitting the text by white spaces and special characters using regular expressions. Depending on the chosen regular expression, white spaces can be considered as a token type or can be completely ignored.</p>
<p>The choice of removing white spaces depends on the application. While the removal of this character type decreases compute resource demands, keeping white spaces is beneficial for processing programming languages, in some programming languages, these white spaces are essential due to indentation and spacing sensitivity and cannot be ignored.</p>
<p>In the example above, the white spaces are ignored because we are dealing with raw text, which is not indentation sensitive.</p>
<p>You can include white spaces by using this regular expression:</p>
<pre><code class="language-python">r'([\w+|\s+|^\w\s])'
</code></pre>
<p>Afterwards, remaining white spaces are stripped away from the tokens so that only the word or special character is left. Moreover, a reverse vocabulary is generated, which is necessary for converting the tokens back into text.</p>
<pre><code class="language-python">def generate_vocab(text):
    chunks = re.split(r'(\w+|[^\w\s])', text)
    unique_tokens = [c for c in chunks if c.strip()]
    encode_vocab = {token: idx for idx, token in enumerate(unique_tokens)}
    decode_vocab = {idx: token for idx, token in enumerate(unique_tokens)}

    return encode_vocab, decode_vocab
</code></pre>
<pre><code class="language-python">encode_vocab, decode_vocab = generate_vocab(text_1)
</code></pre>
<p>Let’s take a look at our vocabulary creation.</p>
<pre><code class="language-python">print(&quot;Vocabulary (token -&gt; index):&quot;)
for idx, token in enumerate(encode_vocab):
    print(f&quot;{idx} -&gt; '{token}'&quot;)
</code></pre>
<p>Overall, our vocabulary consists of 204 unique words.</p>
<pre><code class="language-python">print(&quot;Number of unique tokens:&quot;, len(encode_vocab))
</code></pre>
<h4 id="tokenizing-a-text">Tokenizing a text</h4>
<p>Now we are ready to tokenize input texts based on the created vocabulary. The tokenization process starts similarly to the vocabulary creation process, where the text is split into words and special characters, using the same regular expression as before.</p>
<p>Afterwards, the vocabulary is used to replace each word in the text either with its corresponding number from the vocabulary or the &lt;|unk|&gt; token if the word does not exist in the vocabulary.</p>
<p>In the end, the final tokenized text representation is returned.</p>
<pre><code class="language-python">def encode_text(text, encode_vocab):
    tokens = re.split(r'(\w+|[^\w\s])', text)
    tokens = [t for t in tokens if t.strip()]
    tokens = [encode_vocab.get(token, &quot;&lt;|unk|&gt;&quot;) for token in tokens]
    return tokens
</code></pre>
<p>Let’s test the previous tokenization function on the initial text, which was also used for creating the vocabulary.</p>
<pre><code class="language-python">encoded_text = encode_text(text_1, encode_vocab)
print(&quot;Encoded text:&quot;, encoded_text)
</code></pre>
<p>Now, let’s also test the function of the second text, which was not used for the vocabulary generation.</p>
<pre><code class="language-python">encoded_text = encode_text(text_2, encode_vocab)
print(&quot;Encoded text:&quot;, encoded_text)
</code></pre>
<p>You can see it happened exactly as we previously predicted. Not all words from the second text are present in the first text, which was used to generate the vocabulary, resulting in many unknown out-of-vocabulary tokens.</p>
<p>Right now, we have two possibilities to solve this problem: We can either use character-level tokenization, or we can add the out-of-vocabulary words to our vocabulary. In the next code block, we will follow up by adding the unknown words to the vocabulary.</p>
<p>This is achieved by adding both texts together, separated by the <code>&lt;|endoftext|&gt;</code> token, which indicates to the model that the next text is unrelated to the previous one. Afterwards, the same functions are reused for generating the token representation of the input text.</p>
<pre><code class="language-python">text_corpus = text_1 + &quot; &lt;|endoftext|&gt; &quot; + text_2
encode_vocab, decode_vocab = generate_vocab(text_corpus)
encoded_text = encode_text(text_2, encode_vocab)
print(&quot;Encoded text:&quot;, encoded_text)
</code></pre>
<h4 id="detokenization">Detokenization</h4>
<p>In the end, we would like to go back to the original text from the token representation, so that we humans can understand and interpret it, which is exactly the step that happens after a Large Language Model generates its output. The numerical representations produced by the LLM are converted back by the detokenizer into textual information.</p>
<p>Here, we need the reverse vocabulary, which maps tokens back to words. The detokenization process is similar to the tokenization process, you take the numbers from the token list and replace them with the corresponding words from the vocabulary, separated by white space. These white spaces are removed in front of special characters because they are always attached to a word.</p>
<p>The final list is returned and printed out.</p>
<pre><code class="language-python">def decode_text(tokens, decode_vocab):
    text = ' '.join(decode_vocab.get(idx,'&lt;|unk|&gt;') for idx in tokens)
    text = re.sub(r'\s([?.!,&quot;](?:\s|$))', r'\1', text)
    return text
</code></pre>
<pre><code class="language-python">decode_text = decode_text(encoded_text, decode_vocab)
print(decode_text)
</code></pre>
<h4 id="conclusion">Conclusion</h4>
<p>In this exploration of tokenization, we uncovered the fundamental building blocks that power modern generative AI systems. The post highlighted that there are different tokenization strategies, which vary between models.</p>
<p>The two simplest tokenization strategies — word-level and character-level tokenization — were introduced and implemented, with their pros and cons discussed. The encountered out-of-vocabulary problem of word tokenization, as well as the large token list length of character-level encoding, highlighted that an intermediate solution is needed.</p>
<p>This solution is Byte Pair Encoding (BPE), which is used by almost all modern models.</p>
<h2 id="referencias-references">Referências | References</h2>
<p><a href="https://medium.com/data-science-collective/the-invisible-building-blocks-of-ai-what-you-need-to-know-about-tokenization-acadd86a63ba">The Invisible Building Blocks of AI: What You Need to Know About Tokenization</a></p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../cosmos_tokenizer/wavelet_compression/" class="btn btn-neutral float-left" title="Image Decomposition With Wavelets | Decomposição de imagem com Wavelets"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../../cosmos_applications/cosmos_applications/" class="btn btn-neutral float-right" title="Cosmos Applications">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../cosmos_tokenizer/wavelet_compression/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../../cosmos_applications/cosmos_applications/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../javascripts/mathjax.js"></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
